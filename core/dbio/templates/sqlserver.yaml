core:
  drop_table: IF OBJECT_ID(N'{table}', N'U') IS NOT NULL DROP TABLE {table}
  drop_view: IF OBJECT_ID(N'{view}', N'V') IS NOT NULL DROP VIEW {view}
  drop_index: |
    if exists (
      select name
      from sys.indexes
      where name = '{name}' and object_id = OBJECT_ID('{table}')
    ) drop index {index} on {table}
  replace: insert into {table} ({fields}) values ({values}) on conflict ({pk_fields}) do update set {set_fields}
  replace_temp: |
    insert into {table} ({names})
    select {names} from {temp_table}
    on conflict ({pk_fields}) do nothing;
    update {table} as t1 set {set_fields2}
    from (select * from {temp_table}) as t2
    where {pk_fields_equal}
  limit: select top {limit} {fields} from {table}{where_clause}
  limit_offset: select top {limit} * from ( select {fields} from {table}{where_clause} order by 1 offset {offset} rows) as t
  limit_sql: select top {limit} * from ( {sql} ) as t
  incremental_select_limit: select top {limit} {fields} from {table} where ({incremental_where_cond}){where_and} order by {update_key} asc
  incremental_select_limit_offset: select top {limit} * from ( select {fields} from {table}  where ({incremental_where_cond}){where_and} order by {update_key} asc offset {offset} rows) as t
  incremental_select: select {fields} from {table} where ({incremental_where_cond}){where_and}
  insert: insert into {table} ({fields}) values ({values})
  insert_temp: insert into {table} ({fields}) select {cols} from {temp_table}
  insert_ignore: insert into {table} ({fields}) values ({values}) on conflict ({pk_fields}) do nothing
  insert_ignore_temp: insert into {table} ({names}) select {names} from {temp_table} on conflict ({pk_fields}) do nothing
  update_temp: |
    update {table} as t1 set {set_fields2}
    from (select * from {temp_table}) as t2
    where {pk_fields_equal2}
  sample: select {fields} from {table} TABLESAMPLE SYSTEM (50) limit {n}
  rename_table: ALTER TABLE {table} RENAME TO {new_table}
  rename_column: EXEC sp_rename '{table}.{column}', '{new_column}', 'COLUMN'
  bulk_insert: |
    BULK INSERT {table}
    from '/dev/stdin'
    WITH (
      BATCHSIZE = 5000,
      ERRORFILE = '/dev/stderr',
      MAXERRORS = 0,
      FORMAT = 'CSV',
      FIELDTERMINATOR = ','
    )
  column_names: '{sql}'
  add_column: alter table {table} add {column} {type}
  alter_columns: alter table {table} alter column {col_ddl}
  modify_column: '{column} {type}'

  # SQL Server supports all 4 merge strategies
  merge_insert: |
    INSERT INTO {tgt_table} ({insert_fields})
    SELECT {src_fields} FROM {src_table} src

  merge_update: |
    UPDATE tgt
    SET {set_fields}
    FROM {tgt_table} tgt
    INNER JOIN {src_table} src
    ON {src_tgt_pk_equal}

  merge_update_insert: |
    MERGE INTO {tgt_table} tgt
    USING (SELECT {src_fields} FROM {src_table}) src
    ON ({src_tgt_pk_equal})
    WHEN MATCHED THEN UPDATE SET {set_fields}
    WHEN NOT MATCHED THEN INSERT ({insert_fields}) VALUES ({src_insert_fields});

  merge_delete_insert: |
    DELETE tgt FROM {tgt_table} tgt
    WHERE EXISTS (
      SELECT 1 FROM {src_table} src
      WHERE {src_tgt_pk_equal}
    );
    INSERT INTO {tgt_table} ({insert_fields})
    SELECT {src_fields} FROM {src_table} src

  # Foreign key DDL template
  add_foreign_key: |
    ALTER TABLE {table} ADD CONSTRAINT {constraint} FOREIGN KEY ({column}) REFERENCES {ref_table}({ref_column}){on_delete}{on_update}

  # Column comment/description template (SQL Server uses extended properties)
  add_column_comment: |
    IF EXISTS (SELECT 1 FROM sys.extended_properties WHERE major_id = OBJECT_ID('{schema}.{table_name}') AND minor_id = (SELECT column_id FROM sys.columns WHERE object_id = OBJECT_ID('{schema}.{table_name}') AND name = '{column}') AND name = 'MS_Description')
      EXEC sp_updateextendedproperty @name = N'MS_Description', @value = {comment}, @level0type = N'SCHEMA', @level0name = N'{schema}', @level1type = N'TABLE', @level1name = N'{table_name}', @level2type = N'COLUMN', @level2name = N'{column}'
    ELSE
      EXEC sp_addextendedproperty @name = N'MS_Description', @value = {comment}, @level0type = N'SCHEMA', @level0name = N'{schema}', @level1type = N'TABLE', @level1name = N'{table_name}', @level2type = N'COLUMN', @level2name = N'{column}'

  # Table comment/description template (SQL Server uses extended properties)
  add_table_comment: |
    IF EXISTS (SELECT 1 FROM sys.extended_properties WHERE major_id = OBJECT_ID('{schema}.{table_name}') AND minor_id = 0 AND name = 'MS_Description')
      EXEC sp_updateextendedproperty @name = N'MS_Description', @value = {comment}, @level0type = N'SCHEMA', @level0name = N'{schema}', @level1type = N'TABLE', @level1name = N'{table_name}'
    ELSE
      EXEC sp_addextendedproperty @name = N'MS_Description', @value = {comment}, @level0type = N'SCHEMA', @level0name = N'{schema}', @level1type = N'TABLE', @level1name = N'{table_name}'

metadata:
  databases: select db_name() as name
  
  current_database: select db_name() 
    
  schemas: |
    select schema_name
    from INFORMATION_SCHEMA.SCHEMATA
    order by schema_name
    
  tables: |
    select table_schema as schema_name, table_name, 'false' as is_view
    from INFORMATION_SCHEMA.TABLES
    where table_type = 'BASE TABLE'
      {{if .schema -}} and table_schema = '{schema}' {{- end}}
    order by table_schema, table_name
    
  views: |
    select table_schema as schema_name, table_name, 'true' as is_view
    from INFORMATION_SCHEMA.TABLES
    where table_type = 'VIEW'
      {{if .schema -}} and table_schema = '{schema}' {{- end}}
    order by table_schema, table_name

  columns: |
    select
      column_name,
      data_type,
      character_maximum_length as maximum_length,
      numeric_precision as precision, 
      numeric_scale as scale,
      collation_name,
      cast(collationProperty(collation_name, 'CodePage') as varchar) as collation_code
    from INFORMATION_SCHEMA.COLUMNS
    where table_schema = '{schema}'
      and table_name = '{table}'
    order by ordinal_position

  synonym_database: |
    select 
      s.name as synonym_name,
      PARSENAME(s.base_object_name, 3) as database_name,
      PARSENAME(s.base_object_name, 2) as schema_name,
      PARSENAME(s.base_object_name, 1) as object_name
    from sys.synonyms s
    where schema_name(s.schema_id) = '{schema}'
      and s.name = '{table}'

  columns_synonym: |
    select 
      c.name as column_name,
      t.name as data_type,
      c.precision,
      c.scale
    from sys.synonyms s
    inner join {base_object_database}.sys.objects o 
      on o.object_id = object_id(s.base_object_name)
    inner join {base_object_database}.sys.columns c 
      on c.object_id = o.object_id
    inner join {base_object_database}.sys.types t 
      on t.user_type_id = c.user_type_id
    where schema_name(s.schema_id) = '{schema}'
      and s.name = '{table}'
    order by c.column_id
    
  primary_keys: |
    select tco.constraint_name as pk_name,
           kcu.ordinal_position as position,
           kcu.column_name as column_name
    from INFORMATION_SCHEMA.TABLE_CONSTRAINTS tco
    join INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu 
         on kcu.constraint_name = tco.constraint_name
         and kcu.constraint_schema = tco.constraint_schema
         and kcu.constraint_name = tco.constraint_name
    where kcu.table_schema = '{schema}'
      and kcu.table_name = '{table}'
    order by kcu.table_schema,
             kcu.table_name,
             position

  indexes: |
    SELECT
      ind.name as index_name,
      col.name as column_name
    from sys.indexes ind
    INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id
      and ind.index_id = ic.index_id
    INNER JOIN sys.columns col ON ic.object_id = col.object_id
      and ic.column_id = col.column_id
    INNER JOIN sys.tables t ON ind.object_id = t.object_id
    where schema_name(t.schema_id) = '{schema}' and t.name = '{table}'
      AND ind.is_primary_key = 0
      AND ind.is_unique = 0
      AND ind.is_unique_constraint = 0
      AND t.is_ms_shipped = 0
    ORDER BY
      ind.name,
      ind.index_id,
      ic.index_column_id

  # Extended column attributes for schema migration
  columns_extended: |
    SELECT
      c.name AS column_name,
      CASE WHEN c.is_nullable = 1 THEN 'true' ELSE 'false' END AS is_nullable,
      CASE
        WHEN OBJECT_DEFINITION(c.default_object_id) LIKE '((%' AND OBJECT_DEFINITION(c.default_object_id) LIKE '%))'
        THEN SUBSTRING(OBJECT_DEFINITION(c.default_object_id), 3, LEN(OBJECT_DEFINITION(c.default_object_id)) - 4)
        WHEN OBJECT_DEFINITION(c.default_object_id) LIKE '(%' AND OBJECT_DEFINITION(c.default_object_id) LIKE '%)'
        THEN SUBSTRING(OBJECT_DEFINITION(c.default_object_id), 2, LEN(OBJECT_DEFINITION(c.default_object_id)) - 2)
        ELSE OBJECT_DEFINITION(c.default_object_id)
      END AS default_value,
      CASE WHEN c.is_identity = 1 THEN 'true' ELSE 'false' END AS is_auto_increment,
      CASE WHEN c.is_identity = 1 THEN CAST(IDENT_SEED('{schema}.{table}') AS VARCHAR) ELSE NULL END AS identity_seed,
      CASE WHEN c.is_identity = 1 THEN CAST(IDENT_INCR('{schema}.{table}') AS VARCHAR) ELSE NULL END AS identity_increment,
      CASE WHEN pk.column_id IS NOT NULL THEN 'true' ELSE 'false' END AS is_primary_key,
      ep.value AS description
    FROM sys.columns c
    JOIN sys.tables t ON c.object_id = t.object_id
    JOIN sys.schemas s ON t.schema_id = s.schema_id
    LEFT JOIN sys.extended_properties ep ON ep.major_id = c.object_id AND ep.minor_id = c.column_id AND ep.name = 'MS_Description'
    LEFT JOIN (
      SELECT ic.object_id, ic.column_id
      FROM sys.indexes i
      JOIN sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id
      WHERE i.is_primary_key = 1
    ) pk ON pk.object_id = c.object_id AND pk.column_id = c.column_id
    WHERE s.name = '{schema}' AND t.name = '{table}'
    ORDER BY c.column_id

  # Foreign key relationships
  foreign_keys: |
    SELECT
      fk.name AS constraint_name,
      COL_NAME(fkc.parent_object_id, fkc.parent_column_id) AS column_name,
      SCHEMA_NAME(rt.schema_id) AS referenced_schema,
      rt.name AS referenced_table,
      COL_NAME(fkc.referenced_object_id, fkc.referenced_column_id) AS referenced_column,
      fk.delete_referential_action_desc AS on_delete,
      fk.update_referential_action_desc AS on_update
    FROM sys.foreign_keys fk
    JOIN sys.foreign_key_columns fkc ON fk.object_id = fkc.constraint_object_id
    JOIN sys.tables t ON fk.parent_object_id = t.object_id
    JOIN sys.tables rt ON fk.referenced_object_id = rt.object_id
    JOIN sys.schemas s ON t.schema_id = s.schema_id
    WHERE s.name = '{schema}' AND t.name = '{table}'
    ORDER BY fk.name, fkc.constraint_column_id

  # Extended table attributes for schema migration
  table_extended: |
    SELECT
      CAST(ep.value AS NVARCHAR(MAX)) AS description
    FROM sys.tables t
    JOIN sys.schemas s ON t.schema_id = s.schema_id
    LEFT JOIN sys.extended_properties ep
      ON ep.major_id = t.object_id
      AND ep.minor_id = 0
      AND ep.name = 'MS_Description'
    WHERE s.name = '{schema}' AND t.name = '{table}'

  columns_full: |
    with tables as (
      select
        table_catalog,
        table_schema,
        table_name,
        case table_type
          when 'VIEW' then 'true'
          else 'false'
        end as is_view
      from INFORMATION_SCHEMA.TABLES
      where table_schema = '{schema}' and table_name = '{table}'
    )
    select
      cols.table_schema as schema_name,
      cols.table_name as table_name,
      cols.column_name as column_name,
      cols.data_type as data_type,
      cols.ordinal_position as position,
      cols.collation_name,
      cast(collationProperty(collation_name, 'CodePage') as varchar) as collation_code
    from INFORMATION_SCHEMA.COLUMNS cols
    join tables
      on tables.table_catalog = cols.table_catalog
      and tables.table_schema = cols.table_schema
      and tables.table_name = cols.table_name
    order by cols.table_catalog, cols.table_schema, cols.table_name, cols.ordinal_position

  schemata: |
    with tables as (
      select
        table_catalog,
        table_schema,
        table_name,
        case table_type
          when 'VIEW' then 'true'
          else 'false'
        end as is_view
      from INFORMATION_SCHEMA.TABLES
      where 1=1
        {{if .schema -}} and table_schema = '{schema}' {{- end}}
        {{if .tables -}} and table_name in ({tables}) {{- end}}
    )
    select
      cols.table_schema as schema_name,
      cols.table_name as table_name,
      tables.is_view as is_view,
      cols.column_name as column_name,
      cols.data_type as data_type,
      cols.ordinal_position as position
    from INFORMATION_SCHEMA.COLUMNS cols
    join tables
      on tables.table_catalog = cols.table_catalog
      and tables.table_schema = cols.table_schema
      and tables.table_name = cols.table_name
    order by cols.table_catalog, cols.table_schema, cols.table_name, cols.ordinal_position
  
  ddl_table:
    exec sp_describe_first_result_set @tsql= N'Select * from "{schema}"."{table}"'
  
  ddl_view: |
    select definition as ddl
    from sys.sql_modules  
    where object_id = object_id('"{schema}"."{table}"')
  
  sessions:
    select *
    from pg_stat_activity
    where state = 'active'

  session_terminate:
    select pg_terminate_backend({pid})

analysis:
  field_chars: |
    select
      '{schema}' as schema_nm,
      '{table}' as table_nm,
      '{field}' as field, sum(case when cast({field} as text) ~ '\n' then 1 else 0 end) as cnt_nline, 
      sum(case when cast({field} as text) ~ '\t' then 1 else 0 end) as cnt_tab, 
      sum(case when cast({field} as text) ~ ',' then 1 else 0 end) as cnt_comma, 
      sum(case when cast({field} as text) ~ '"' then 1 else 0 end) as cnt_dquote, 
      min(datalength(cast({field} as text))) as f_min_len, 
      max(datalength(cast({field} as text))) as f_max_len
    from "{schema}"."{table}"

  field_stat_len: |
    -- field_stat_len {table}
    select
      '{schema}' as schema_nm,
      '{table}' as table_nm,
      '{field}' as field,
      '{type}' as type,
      count(*) as tot_cnt,
      min(datalength({field})) as f_min_len,
      max(datalength({field})) as f_max_len
    from "{schema}"."{table}"

  field_stat_deep: |
    select
      '{schema}' as schema_nm,
      '{table}' as table_nm,
      '{field}' as field,
      count(*) as tot_cnt,
      count({field}) as f_cnt,
      count(*) - count({field}) as f_null_cnt,
      round(100.0 * (count(*) - count({field})) / count(*),1) as f_null_prct,
      count(distinct {field}) as f_dstct_cnt,
      round(100.0 * count(distinct {field}) / count(*),1) as f_dstct_prct,
      count(*) - count(distinct {field}) as f_dup_cnt,
      min({field}) as f_min,
      max({field}) as f_max,
      min(datalength(cast({field} as text))) as f_min_len,
      max(datalength(cast({field} as text))) as f_max_len
    from "{schema}"."{table}"

  distro_field: |
    with t1 as (
      select
        '{field}'::text as field,
        {field},
        count(*) cnt
      from "{schema}"."{table}"
      group by {field}
      order by count(*) desc
    )
    , t2 as (
      select
        '{field}'::text as field,
        count(*) ttl_cnt
      from "{schema}"."{table}"
    )
    select
      '{table}' as table_nm,
      t1.field,
      {field} as value,
      cnt,
      round(100.0 * cnt / ttl_cnt, 2) as prct
    from t1
    join t2
      on t1.field = t2.field
    order by cnt desc

  distro_field_group: |
    with t1 as (
      select
        '{field}'::text as field,
        {group_expr} as group_exp,
        {field},        
        count(*) cnt
      from "{schema}"."{table}"
      group by {field}, {group_expr}
      order by count(*) desc
    )
    , t2 as (
      select
        '{field}'::text as field,
        count(*) ttl_cnt
      from "{schema}"."{table}"
    )
    select
      '{table}' as table_nm,
      t1.field,
      t1.group_exp,
      {field} as value,
      cnt,
      round(100.0 * cnt / ttl_cnt, 2) as prct
    from t1
    join t2
      on t1.field = t2.field
    order by cnt desc

  distro_field_date: |
    with t1 as (
        select
          '{field}'::text as field,
          extract(year from {field}) as year,
          extract(month from {field}) as month,
          count(*) cnt
        from "{schema}"."{table}"
        group by extract(year from {field}), extract(month from {field})
        order by extract(year from {field}), extract(month from {field})
      )
      , t2 as (
        select '{field}'::text as field, count(*) ttl_cnt
        from "{schema}"."{table}"
      )
      select 
        '{schema}' as schema_nm,
        '{table}' as table_nm,
        t1.field,
        t1.year,
        t1.month,
        cnt,
        round(100.0 * cnt / ttl_cnt, 2) as prct
      from t1
      join t2
        on t1.field = t2.field
      order by t1.year, t1.month

function:
  truncate_f: round({field}, 2, 1)
  truncate_datef: CONVERT(DATETIME, CONVERT(DATE, {field}))
  sleep: waitfor delay '00:00:{seconds}.000'
  cast_to_text: 'cast({field} as nvarchar(max))'
  checksum_string: datalength({field})
  checksum_integer: 'CAST({field} as bigint)'
  checksum_boolean: len({field})
  checksum_json: datalength(replace(CONVERT(VARCHAR(MAX), {field}), ' ', ''))
  checksum_date: (CAST(DATEDIFF(ss, '01-01-1970 00:00:00', {field}) as bigint) * 1000000)
  checksum_datetime: (CAST(DATEDIFF(ss, '01-01-1970 00:00:00', {field}) as bigint) * 1000000) + DATEPART(microsecond, {field})
  checksum_decimal: ABS(CAST({field} as bigint))


variable:
  timestamp_layout: '2006-01-02 15:04:05.0000000'
  timestamp_layout_str: "cast('{value}' as datetime2)"

  # https://stackoverflow.com/a/17867687/2295355
  timestampz_layout_str: "ToDateTimeOffset('{value}')"
  timestampz_layout: "2006-01-02 15:04:05.0000000', '-07:00"
  
  bind_string: "@p{c}"
  batch_rows: 200
  batch_values: 1000
  bool_as: string
  error_filter_table_exists: already
  max_string_type: nvarchar(max)
  max_string_length: 4000
  max_column_length: 128

native_type_map:
  bigint: bigint
  binary: binary
  bit: bool
  char: string
  date: date
  datetime: datetime
  datetime2: datetime
  datetimeoffset: timestampz
  decimal: decimal
  float: float
  image: binary
  int: integer
  money: decimal
  nchar: text
  ntext: text
  numeric: decimal
  nvarchar: text
  real: float
  smalldatetime: datetime
  smallint: smallint
  smallmoney: decimal
  sql_variant: text
  text: text
  time: time
  timestamp: binary
  tinyint: smallint
  uniqueidentifier: uuid
  varbinary: binary
  varchar: text

general_type_map:
  bigint: bigint
  binary: varbinary
  bool: bit
  date: date
  datetime: datetime2
  decimal: "decimal(,)"
  float: float
  integer: integer
  json: "nvarchar(max)"
  smallint: smallint
  string: "nvarchar()"
  text: "nvarchar(max)"
  time: "varchar()"
  timestamp: datetime2
  timestampz: datetimeoffset
  timez: "varchar()"
  uuid: uniqueidentifier

# Schema migration: default value translation between native and generalized forms
default_value_map:
  to_general:
    "getdate()": "current_timestamp"
    "(getdate())": "current_timestamp"
    "GETDATE()": "current_timestamp"
    "(GETDATE())": "current_timestamp"
    "sysdatetime()": "current_timestamp"
    "(sysdatetime())": "current_timestamp"
    "getutcdate()": "current_timestamp_utc"
    "(getutcdate())": "current_timestamp_utc"
    "GETUTCDATE()": "current_timestamp_utc"
    "(GETUTCDATE())": "current_timestamp_utc"
    "newid()": "uuid()"
    "(newid())": "uuid()"
    "NEWID()": "uuid()"
    "(NEWID())": "uuid()"
    "newsequentialid()": "uuid()"
    "(newsequentialid())": "uuid()"
    "((1))": "true"
    "((0))": "false"
    "(1)": "true"
    "(0)": "false"
  from_general:
    "current_timestamp": "GETDATE()"
    "current_timestamp_utc": "GETUTCDATE()"
    "current_date": "CAST(GETDATE() AS DATE)"
    "current_time": "CAST(GETDATE() AS TIME)"
    "uuid()": "NEWID()"
    "true": "1"
    "false": "0"
    "null": "NULL"
