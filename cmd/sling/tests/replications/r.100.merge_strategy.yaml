# Test merge_strategy target option
# Tests that merge strategies work correctly when specified in replication config

source: postgres
target: postgres

defaults:
  mode: incremental
  primary_key: id

hooks:
  start:
    # Setup: Create and populate test tables
    - type: query
      connection: '{source.name}'
      query: |
        DROP TABLE IF EXISTS public.test_merge_strategy_ui;
        DROP TABLE IF EXISTS public.test_merge_strategy_di;
        DROP TABLE IF EXISTS public.test_merge_strategy_ins;
        DROP TABLE IF EXISTS public.test_merge_strategy_upd;

        -- Create source tables with initial data
        CREATE TABLE public.test_merge_strategy_ui (id int PRIMARY KEY, val text);
        INSERT INTO public.test_merge_strategy_ui VALUES (1, 'initial_a'), (2, 'initial_b');

        CREATE TABLE public.test_merge_strategy_di (id int PRIMARY KEY, val text);
        INSERT INTO public.test_merge_strategy_di VALUES (1, 'initial_a'), (2, 'initial_b');

        CREATE TABLE public.test_merge_strategy_ins (id int, val text);
        INSERT INTO public.test_merge_strategy_ins VALUES (1, 'initial_a'), (2, 'initial_b');

        CREATE TABLE public.test_merge_strategy_upd (id int PRIMARY KEY, val text);
        INSERT INTO public.test_merge_strategy_upd VALUES (1, 'initial_a'), (2, 'initial_b');

  end:
    # if errored, do not proceed
    - type: check
      check: execution.status.error == 0
      on_failure: break

    # Verify update_insert strategy: data should be updated and inserted
    - type: query
      connection: '{target.name}'
      query: SELECT count(*) as cnt FROM public.test_merge_strategy_ui
      into: count_ui

    - type: query
      connection: '{target.name}'
      query: SELECT val FROM public.test_merge_strategy_ui WHERE id = 1
      into: result_ui

    - type: log
      message: |
        update_insert count => {store.count_ui}
        update_insert row 1 => {store.result_ui}

    - type: check
      check: int_parse(store.count_ui[0].cnt) == 3
      message: "update_insert should have 3 rows (2 updated, 1 new)"

    - type: check
      check: store.result_ui[0].val == "updated_a"
      message: "update_insert should update existing row id=1"

    # Verify delete_insert strategy: data should be replaced
    - type: query
      connection: '{target.name}'
      query: SELECT count(*) as cnt FROM public.test_merge_strategy_di
      into: count_di

    - type: query
      connection: '{target.name}'
      query: SELECT val FROM public.test_merge_strategy_di WHERE id = 1
      into: result_di

    - type: log
      message: |
        delete_insert count => {store.count_di}
        delete_insert row 1 => {store.result_di}

    - type: check
      check: int_parse(store.count_di[0].cnt) == 3
      message: "delete_insert should have 3 rows"

    - type: check
      check: store.result_di[0].val == "replaced_a"
      message: "delete_insert should replace row id=1"

    # Verify insert strategy: data should be appended
    - type: query
      connection: '{target.name}'
      query: SELECT count(*) as cnt FROM public.test_merge_strategy_ins
      into: count_ins

    - type: log
      message: |
        insert count => {store.count_ins}

    - type: check
      check: int_parse(store.count_ins[0].cnt) == 3
      message: "insert should have 3 rows (full-refresh mode overwrites)"

    # Verify update strategy: only existing rows should be updated, no new rows inserted
    - type: query
      connection: '{target.name}'
      query: SELECT count(*) as cnt FROM public.test_merge_strategy_upd
      into: count_upd

    - type: query
      connection: '{target.name}'
      query: SELECT val FROM public.test_merge_strategy_upd WHERE id = 1
      into: result_upd

    - type: query
      connection: '{target.name}'
      query: SELECT count(*) as cnt FROM public.test_merge_strategy_upd WHERE id = 3
      into: result_upd_new

    - type: log
      message: |
        update count => {store.count_upd}
        update row 1 => {store.result_upd}
        update new row check => {store.result_upd_new}

    - type: check
      check: int_parse(store.count_upd[0].cnt) == 2
      message: "update should still have 2 rows (no new rows inserted)"

    - type: check
      check: store.result_upd[0].val == "updated_a"
      message: "update should update existing row id=1"

    - type: check
      check: int_parse(store.result_upd_new[0].cnt) == 0
      message: "update should NOT insert new row id=3"

    # Cleanup
    - type: query
      connection: '{source.name}'
      query: |
        DROP TABLE IF EXISTS public.test_merge_strategy_ui;
        DROP TABLE IF EXISTS public.test_merge_strategy_di;
        DROP TABLE IF EXISTS public.test_merge_strategy_ins;
        DROP TABLE IF EXISTS public.test_merge_strategy_upd;

streams:
  # Test update_insert strategy
  test_merge_strategy_ui:
    sql: |
      SELECT 1 as id, 'updated_a' as val
      UNION ALL SELECT 2 as id, 'updated_b' as val
      UNION ALL SELECT 3 as id, 'new_c' as val
    object: public.test_merge_strategy_ui
    target_options:
      merge_strategy: update_insert

  # Test delete_insert strategy
  test_merge_strategy_di:
    sql: |
      SELECT 1 as id, 'replaced_a' as val
      UNION ALL SELECT 2 as id, 'replaced_b' as val
      UNION ALL SELECT 3 as id, 'new_c' as val
    object: public.test_merge_strategy_di
    target_options:
      merge_strategy: delete_insert

  # Test insert strategy (full-refresh mode)
  test_merge_strategy_ins:
    sql: |
      SELECT 1 as id, 'new_dup_a' as val
      UNION ALL SELECT 4 as id, 'new_d' as val
      UNION ALL SELECT 5 as id, 'new_e' as val
    object: public.test_merge_strategy_ins
    mode: full-refresh
    primary_key: []
    target_options:
      merge_strategy: insert

  # Test update strategy (only updates existing rows, no inserts)
  test_merge_strategy_upd:
    sql: |
      SELECT 1 as id, 'updated_a' as val
      UNION ALL SELECT 2 as id, 'updated_b' as val
      UNION ALL SELECT 3 as id, 'new_c' as val
    object: public.test_merge_strategy_upd
    target_options:
      merge_strategy: update
