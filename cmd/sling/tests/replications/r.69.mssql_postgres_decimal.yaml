source: MSSQL
target: POSTGRES

hooks:
  start:
    - type: query
      connection: '{source.name}'
      query: |
        -- Drop table if exists
        IF OBJECT_ID('dbo.decimal_test', 'U') IS NOT NULL DROP TABLE dbo.decimal_test;

        -- Create source table with various decimal types
        CREATE TABLE dbo.decimal_test (
          id INT PRIMARY KEY,
          decimal_6_5 DECIMAL(6,5),
          decimal_10_4 DECIMAL(10,4),
          decimal_18_6 DECIMAL(18,6),
          numeric_12_3 NUMERIC(12,3),
          money_col MONEY,
          smallmoney_col SMALLMONEY,
          description NVARCHAR(100)
        );

        -- Insert 10 rows with various decimal values
        INSERT INTO dbo.decimal_test VALUES
        (1, 1.23450, 1234.5678, 123456.789012, 12345.678, 12345.6789, 123.4567, N'Basic positive values'),
        (2, -1.23450, -1234.5678, -123456.789012, -12345.678, -12345.6789, -123.4567, N'Basic negative values'),
        (3, 0.00100, 0.0001, 0.000001, 0.001, 0.01, 0.01, N'Very small values'),
        (4, 9.99999, 999999.9999, 999999999999.999999, 999999999.999, 922337203685477.5807, 214748.3647, N'Maximum values'),
        (5, -9.99999, -999999.9999, -999999999999.999999, -999999999.999, -922337203685477.5808, -214748.3648, N'Minimum values'),
        (6, 0.00000, 0.0000, 0.000000, 0.000, 0.00, 0.00, N'Zero values'),
        (7, 1.23000, 123.4500, 1234.567800, 123.450, 123.45, 12.34, N'Trailing zeros'),
        (8, 1.11110, 11.1111, 111.111111, 1111.111, 1111.1111, 11.1111, N'Repeating digits'),
        (9, 5.05050, 5050.5050, 505050.505050, 50505.050, 50505.0505, 505.0505, N'Alternating digits'),
        (10, 9.99990, 9999.9999, 999999.999999, 99999.999, 99999.9999, 999.9999, N'All nines');

    - type: query
      connection: '{source.name}'
      query: SELECT COUNT(*) as count FROM dbo.decimal_test
      into: source_count

    - type: log
      message: |
        Created MSSQL source table with {store.source_count[0].count} rows containing decimal test data

  end:
    # if errored, do not proceed
    - type: check
      check: execution.status.error == 0
      on_failure: break

    - type: query
      connection: '{target.name}'
      query: |
        SELECT COUNT(*) as count FROM public.decimal_test
      into: target_count

    - type: log
      message: |
        Target table row count: {store.target_count[0].count}

    # Verify row count matches
    - type: check
      check: store.source_count[0].count == store.target_count[0].count
      failure_message: "Row count mismatch: source has {store.source_count[0].count} rows, target has {store.target_count[0].count} rows"

    # Get source data
    - type: query
      connection: '{source.name}'
      query: |
        SELECT
          id,
          decimal_6_5,
          decimal_10_4,
          decimal_18_6,
          numeric_12_3,
          money_col,
          smallmoney_col,
          description
        FROM dbo.decimal_test
        ORDER BY id
      into: source_data

    # Get target data
    - type: query
      connection: '{target.name}'
      query: |
        SELECT
          id,
          decimal_6_5,
          decimal_10_4,
          decimal_18_6,
          numeric_12_3,
          money_col,
          smallmoney_col,
          description
        FROM public.decimal_test
        ORDER BY id
      into: target_data

    - type: log
      message: |
        Source data:
        {pretty_table(store.source_data)}

    - type: log
      message: |
        Target data:
        {pretty_table(store.target_data)}

    # Check decimal precision for each row
    - type: check
      check: pretty_table(store.source_data) == pretty_table(store.target_data)
      failure_message: "Table mismatch: pretty_table(store.source_data) == pretty_table(store.target_data)"

    - type: check
      check: float_parse(store.source_data[0].decimal_6_5) == float_parse(store.target_data[0].decimal_6_5)
      failure_message: "Row 1 decimal_6_5 mismatch: source={store.source_data[0].decimal_6_5}, target={store.target_data[0].decimal_6_5}"

    - type: check
      check: float_parse(store.source_data[0].decimal_10_4) == float_parse(store.target_data[0].decimal_10_4)
      failure_message: "Row 1 decimal_10_4 mismatch: source={store.source_data[0].decimal_10_4}, target={store.target_data[0].decimal_10_4}"

    - type: check
      check: float_parse(store.source_data[0].decimal_18_6) == float_parse(store.target_data[0].decimal_18_6)
      failure_message: "Row 1 decimal_18_6 mismatch: source={store.source_data[0].decimal_18_6}, target={store.target_data[0].decimal_18_6}"

    - type: check
      check: float_parse(store.source_data[2].decimal_6_5) == float_parse(store.target_data[2].decimal_6_5)
      failure_message: "Row 3 (small values) decimal_6_5 mismatch: source={store.source_data[2].decimal_6_5}, target={store.target_data[2].decimal_6_5}"

    - type: check
      check: float_parse(store.source_data[2].decimal_10_4) == float_parse(store.target_data[2].decimal_10_4)
      failure_message: "Row 3 (small values) decimal_10_4 mismatch: source={store.source_data[2].decimal_10_4}, target={store.target_data[2].decimal_10_4}"

    - type: check
      check: float_parse(store.source_data[3].money_col) == float_parse(store.target_data[3].money_col)
      failure_message: "Row 4 (max values) money_col mismatch: source={store.source_data[3].money_col}, target={store.target_data[3].money_col}"

    # Clean up
    - type: query
      connection: '{source.name}'
      query: IF OBJECT_ID('dbo.decimal_test', 'U') IS NOT NULL DROP TABLE dbo.decimal_test

    - type: query
      connection: '{target.name}'
      query: DROP TABLE IF EXISTS public.decimal_test CASCADE

streams:
  dbo.decimal_test:
    object: public.decimal_test
    mode: full-refresh
    target_options:
      isolation_level: read_committed
      column_casing: lower
